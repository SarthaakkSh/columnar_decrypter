<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QR Cipher Decryptor — Columnar Transposition</title>
  <style>
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; max-width:900px; margin:20px auto; padding:16px; }
    h1 { font-size:1.25rem; margin-bottom:0.25rem }
    .row { display:flex; gap:12px; flex-wrap:wrap }
    .card { border:1px solid #ddd; padding:12px; border-radius:8px; background:#fafafa; flex:1 1 300px }
    label { display:block; margin-top:8px; font-weight:600 }
    input[type="text"], textarea { width:100%; padding:8px; font-size:1rem; box-sizing:border-box }
    button { padding:8px 12px; font-size:1rem; margin-top:8px }
    #qr-region { min-height:260px }
    pre { white-space:pre-wrap; word-break:break-word; background:#fff; padding:8px; border-radius:6px }
    .hint { color:#555; font-size:0.9rem }
  </style>
</head>
<body>
  <h1>QR Decryptor — Columnar Transposition Cipher</h1>
  <p class="hint">Scan a QR (camera or file) that contains the <em>ciphertext</em>, or paste ciphertext manually. Enter the keyword used for the columnar transposition cipher and press <strong>Decrypt</strong>.</p>

  <div class="row">
    <div class="card">
      <h2>Scan QR</h2>
      <div id="qr-region"></div>
      <div style="margin-top:8px">
        <button id="start-camera">Start Camera Scanner</button>
        <button id="stop-camera" disabled>Stop Camera</button>
      </div>
      <div style="margin-top:8px">
        <label for="qr-file">Or choose a QR image file</label>
        <input id="qr-file" type="file" accept="image/*" />
      </div>
    </div>

    <div class="card">
      <h2>Decrypt</h2>
      <label for="ciphertext">Ciphertext (from QR or paste)</label>
      <textarea id="ciphertext" rows="6" placeholder="Ciphertext will appear here after scanning, or paste it manually"></textarea>

      <label for="keyword">Keyword</label>
      <input id="keyword" type="text" placeholder="Enter keyword used during encryption" />

      <div style="margin-top:10px">
        <button id="decrypt">Decrypt</button>
        <button id="copy-plain">Copy Plaintext</button>
        <button id="show-info">Show Info (keyword/orig/cipher)</button>
      </div>

      <label for="plaintext">Decrypted plaintext</label>
      <pre id="plaintext">(not decrypted yet)</pre>

      <p class="hint">Note: This implementation strips trailing 'X' or 'x' characters used as padding during encryption. If the original message legitimately ended with 'X' or 'x', this may remove them as well — that ambiguity is an inherent limitation of simple padding.</p>
    </div>
  </div>

  <script src="https://unpkg.com/html5-qrcode@2.3.7/minified/html5-qrcode.min.js"></script>
  <script>
    // --- Columnar transposition decryption (preserves all characters and case) ---
    function keywordOrder(keyword) {
      // Produce order array where each column index maps to its rank in the sorted keyword
      // stable sort by letter then by original index
      const arr = Array.from(keyword).map((ch, i) => ({ch, i}));
      const sorted = arr.slice().sort((a,b) => {
        const A = a.ch.toUpperCase(); const B = b.ch.toUpperCase();
        if (A < B) return -1; if (A > B) return 1; return a.i - b.i;
      });
      const order = new Array(keyword.length);
      for (let rank = 0; rank < sorted.length; ++rank) {
        order[sorted[rank].i] = rank;
      }
      return order;
    }

    function decryptColumnar(ciphertext, keyword) {
      if (!keyword) return {error: 'Keyword required'};
      const cols = keyword.length;
      const len = ciphertext.length;
      const rows = Math.ceil(len / cols);
      const order = keywordOrder(keyword);

      // create empty matrix rows x cols
      const matrix = Array.from({length: rows}, () => new Array(cols).fill(''));

      // Fill columns in order of keyword-sorted ranks
      let k = 0;
      const colIndicesByRank = [...Array(cols).keys()].sort((a,b) => order[a] - order[b]);
      for (const col of colIndicesByRank) {
        for (let r = 0; r < rows; ++r) {
          if (k < len) {
            matrix[r][col] = ciphertext[k++];
          } else {
            matrix[r][col] = '';
          }
        }
      }

      // Read row-wise to reconstruct plaintext
      let plaintext = '';
      for (let r = 0; r < rows; ++r) {
        for (let c = 0; c < cols; ++c) {
          plaintext += matrix[r][c] || '';
        }
      }

      // Remove padding: strip trailing X or x characters that were added as padding
      plaintext = plaintext.replace(/[Xx]+$/g, '');

      return {plaintext};
    }

    // --- UI wiring ---
    const ciphertextEl = document.getElementById('ciphertext');
    const plaintextEl = document.getElementById('plaintext');
    const keywordEl = document.getElementById('keyword');
    const decryptBtn = document.getElementById('decrypt');
    const copyBtn = document.getElementById('copy-plain');
    const infoBtn = document.getElementById('show-info');

    decryptBtn.addEventListener('click', () => {
      const ct = ciphertextEl.value.trim();
      const kw = keywordEl.value.trim();
      if (!ct) { alert('Ciphertext is empty'); return; }
      if (!kw) { alert('Keyword is required'); return; }
      const res = decryptColumnar(ct, kw);
      if (res.error) { alert(res.error); return; }
      plaintextEl.textContent = res.plaintext || '(empty after removing padding)';
    });

    copyBtn.addEventListener('click', async () => {
      const text = plaintextEl.textContent;
      try {
        await navigator.clipboard.writeText(text);
        alert('Plaintext copied to clipboard');
      } catch(e) {
        alert('Copy failed — select and copy manually');
      }
    });

    infoBtn.addEventListener('click', () => {
      alert('Keyword: ' + keywordEl.value + "\n\nCiphertext: " + ciphertextEl.value + "\n\nDecrypted: " + plaintextEl.textContent);
    });

    // --- QR scanning using html5-qrcode ---
    let html5QrScanner = null;
    const qrRegion = document.getElementById('qr-region');
    const startBtn = document.getElementById('start-camera');
    const stopBtn = document.getElementById('stop-camera');
    startBtn.addEventListener('click', async () => {
      // initialize scanner
      if (html5QrScanner) return;
      qrRegion.innerHTML = '<div id="reader" style="width:100%"></div>';
      const reader = document.getElementById('reader');
      html5QrScanner = new Html5Qrcode("reader");
      try {
        const devices = await Html5Qrcode.getCameras();
        const cameraId = devices && devices.length ? devices[0].id : null;
        await html5QrScanner.start(
          cameraId,
          { fps: 10, qrbox: 250 },
          qrCodeMessage => {
            // on success
            ciphertextEl.value = qrCodeMessage;
            // auto-decrypt if keyword provided
            const kw = keywordEl.value.trim();
            if (kw) {
              const res = decryptColumnar(qrCodeMessage, kw);
              plaintextEl.textContent = res.plaintext || '(empty after padding removal)';
            }
          },
          errorMessage => {
            // console.log('scan failed', errorMessage);
          }
        );
        startBtn.disabled = true; stopBtn.disabled = false;
      } catch (err) {
        alert('Camera start failed: ' + err);
        html5QrScanner = null;
      }
    });

    stopBtn.addEventListener('click', async () => {
      if (!html5QrScanner) return;
      await html5QrScanner.stop();
      html5QrScanner.clear();
      html5QrScanner = null;
      qrRegion.innerHTML = '';
      startBtn.disabled = false; stopBtn.disabled = true;
    });

    // File input scanning (choose image)
    document.getElementById('qr-file').addEventListener('change', async (ev) => {
      const fi = ev.target.files && ev.target.files[0];
      if (!fi) return;
      try {
        const result = await Html5Qrcode.scanFile(fi, true);
        ciphertextEl.value = result; // result is the decoded text
      } catch (e) {
        alert('Could not decode image: ' + e);
      }
    });

    // When user pastes ciphertext or changes keyword we can optionally try auto-decrypt
    keywordEl.addEventListener('input', () => {
      const ct = ciphertextEl.value.trim(); const kw = keywordEl.value.trim();
      if (ct && kw) {
        const res = decryptColumnar(ct, kw);
        plaintextEl.textContent = res.plaintext || '(empty after padding removal)';
      }
    });

  </script>
</body>
</html>
